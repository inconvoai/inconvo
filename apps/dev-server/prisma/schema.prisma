generator client {
  provider = "prisma-client"
  output   = "./generated/client"
}

datasource db {
  provider = "sqlite"
}

// Semantic model configuration tables

model Table {
  id                String             @id @default(uuid())
  name              String             @unique
  access            String             @default("OFF") // QUERYABLE, JOINABLE, OFF
  context           String?
  columns           Column[]
  computedColumns   ComputedColumn[]
  outwardRelations  Relation[]         @relation("relation_source")
  inwardRelations   Relation[]         @relation("relation_target")
  columnConversions ColumnConversion[]
  condition         TableCondition?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
}

model Column {
  id                     String                  @id @default(uuid())
  name                   String
  rename                 String?
  notes                  String?
  type                   String
  selected               Boolean                 @default(true)
  unit                   String?
  tableId                String
  table                  Table                   @relation(fields: [tableId], references: [id], onDelete: Cascade)
  sourceRelationMappings RelationColumnMapping[] @relation("mapping_source")
  targetRelationMappings RelationColumnMapping[] @relation("mapping_target")
  conversion             ColumnConversion?
  conditions             TableCondition[]
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt

  @@unique([tableId, name])
}

model ComputedColumn {
  id        String   @id @default(uuid())
  name      String
  type      String
  ast       String // JSON stored as string in SQLite
  selected  Boolean  @default(true)
  unit      String?
  notes     String?
  tableId   String
  table     Table    @relation(fields: [tableId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tableId, name])
}

model Relation {
  id             String                  @id @default(uuid())
  name           String
  isList         Boolean
  selected       Boolean                 @default(true)
  source         String                  @default("FK") // FK, MANUAL
  status         String                  @default("VALID") // VALID, BROKEN
  errorTag       String?
  sourceTableId  String
  targetTableId  String
  sourceTable    Table                   @relation("relation_source", fields: [sourceTableId], references: [id], onDelete: Cascade)
  targetTable    Table                   @relation("relation_target", fields: [targetTableId], references: [id], onDelete: Cascade)
  columnMappings RelationColumnMapping[]
  createdAt      DateTime                @default(now())
  updatedAt      DateTime                @updatedAt

  @@unique([sourceTableId, name])
}

model RelationColumnMapping {
  id               String   @id @default(uuid())
  relationId       String
  sourceColumnId   String?
  targetColumnId   String?
  sourceColumnName String
  targetColumnName String
  position         Int
  relation         Relation @relation(fields: [relationId], references: [id], onDelete: Cascade)
  sourceColumn     Column?  @relation("mapping_source", fields: [sourceColumnId], references: [id], onDelete: SetNull)
  targetColumn     Column?  @relation("mapping_target", fields: [targetColumnId], references: [id], onDelete: SetNull)

  @@unique([relationId, position])
}

model ColumnConversion {
  id       String  @id @default(uuid())
  ast      String // JSON stored as string in SQLite
  type     String?
  selected Boolean @default(true)
  columnId String  @unique
  tableId  String
  column   Column  @relation(fields: [columnId], references: [id], onDelete: Cascade)
  table    Table   @relation(fields: [tableId], references: [id], onDelete: Cascade)

  @@index([tableId])
}

model TableCondition {
  id                 String           @id @default(uuid())
  columnId           String
  tableId            String           @unique
  userContextFieldId String
  column             Column           @relation(fields: [columnId], references: [id], onDelete: Cascade)
  table              Table            @relation(fields: [tableId], references: [id], onDelete: Cascade)
  userContextField   UserContextField @relation(fields: [userContextFieldId], references: [id], onDelete: Cascade)
}

model UserContextField {
  id              String           @id @default(uuid())
  key             String           @unique
  type            String // STRING, NUMBER
  tableConditions TableCondition[]
}
