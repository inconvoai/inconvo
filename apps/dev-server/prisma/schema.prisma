generator client {
  provider = "prisma-client"
  output   = "./generated/client"
}

datasource db {
  provider = "sqlite"
}

model Table {
  id                String             @id @default(uuid())
  name              String             @unique
  schema            String?            // Database schema name (e.g., 'public', 'sales')
  access            String             @default("OFF")
  context           String?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  columns           Column[]
  columnConversions ColumnConversion[]
  computedColumns   ComputedColumn[]
  inwardRelations   Relation[]         @relation("relation_target")
  outwardRelations  Relation[]         @relation("relation_source")
  condition         TableCondition?
}

model Column {
  id                     String                  @id @default(uuid())
  name                   String
  rename                 String?
  notes                  String?
  type                   String
  selected               Boolean                 @default(true)
  unit                   String?
  tableId                String
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt
  table                  Table                   @relation(fields: [tableId], references: [id], onDelete: Cascade)
  conversion             ColumnConversion?
  targetRelationMappings RelationColumnMapping[] @relation("mapping_target")
  sourceRelationMappings RelationColumnMapping[] @relation("mapping_source")
  conditions             TableCondition[]

  @@unique([tableId, name])
}

model ComputedColumn {
  id        String   @id @default(uuid())
  name      String
  type      String
  ast       String
  selected  Boolean  @default(true)
  unit      String?
  notes     String?
  tableId   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  table     Table    @relation(fields: [tableId], references: [id], onDelete: Cascade)

  @@unique([tableId, name])
}

model Relation {
  id             String                  @id @default(uuid())
  name           String
  isList         Boolean
  selected       Boolean                 @default(true)
  source         String                  @default("FK")
  status         String                  @default("VALID")
  errorTag       String?
  sourceTableId  String
  targetTableId  String
  createdAt      DateTime                @default(now())
  updatedAt      DateTime                @updatedAt
  targetTable    Table                   @relation("relation_target", fields: [targetTableId], references: [id], onDelete: Cascade)
  sourceTable    Table                   @relation("relation_source", fields: [sourceTableId], references: [id], onDelete: Cascade)
  columnMappings RelationColumnMapping[]

  @@unique([sourceTableId, name])
}

model RelationColumnMapping {
  id               String   @id @default(uuid())
  relationId       String
  sourceColumnId   String?
  targetColumnId   String?
  sourceColumnName String
  targetColumnName String
  position         Int
  targetColumn     Column?  @relation("mapping_target", fields: [targetColumnId], references: [id])
  sourceColumn     Column?  @relation("mapping_source", fields: [sourceColumnId], references: [id])
  relation         Relation @relation(fields: [relationId], references: [id], onDelete: Cascade)

  @@unique([relationId, position])
}

model ColumnConversion {
  id       String  @id @default(uuid())
  ast      String
  type     String?
  selected Boolean @default(true)
  columnId String  @unique
  tableId  String
  table    Table   @relation(fields: [tableId], references: [id], onDelete: Cascade)
  column   Column  @relation(fields: [columnId], references: [id], onDelete: Cascade)

  @@index([tableId])
}

model TableCondition {
  id                 String           @id @default(uuid())
  columnId           String
  tableId            String           @unique
  userContextFieldId String
  userContextField   UserContextField @relation(fields: [userContextFieldId], references: [id], onDelete: Cascade)
  table              Table            @relation(fields: [tableId], references: [id], onDelete: Cascade)
  column             Column           @relation(fields: [columnId], references: [id], onDelete: Cascade)
}

model UserContextField {
  id              String           @id @default(uuid())
  key             String           @unique
  type            String
  tableConditions TableCondition[]
}

model Conversation {
  id             String   @id
  userIdentifier String
  userContext    String?
  title          String?
  messages       String   @default("[]")
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([userIdentifier])
}

model checkpoints {
  thread_id            String
  checkpoint_ns        String  @default("")
  checkpoint_id        String
  parent_checkpoint_id String?
  type                 String?
  checkpoint           Bytes?
  metadata             Bytes?

  @@id([thread_id, checkpoint_ns, checkpoint_id])
}

model writes {
  thread_id     String
  checkpoint_ns String  @default("")
  checkpoint_id String
  task_id       String
  idx           Int
  channel       String
  type          String?
  value         Bytes?

  @@id([thread_id, checkpoint_ns, checkpoint_id, task_id, idx])
}
