generator client {
  provider = "prisma-client"
  output   = "./generated/client"
}

datasource db {
  provider = "sqlite"
}

model Table {
  id                String              @id @default(uuid())
  name              String              @unique
  schema            String?             // Database schema name (e.g., 'public', 'sales')
  source            String              @default("PHYSICAL")
  access            String              @default("OFF")
  context           String?
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  columns           Column[]
  computedColumns   ComputedColumn[]
  inwardRelations   Relation[]          @relation("relation_target")
  outwardRelations  Relation[]          @relation("relation_source")
  condition         TableCondition?
  accessPolicy      TableAccessPolicy?
  columnAugmentations ColumnAugmentation[]
  virtualTableConfig  VirtualTableConfig?
}

model VirtualTableConfig {
  id        String   @id @default(uuid())
  tableId   String   @unique
  dialect   String
  sql       String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  table     Table    @relation(fields: [tableId], references: [id], onDelete: Cascade)
}

model Column {
  id                     String                  @id @default(uuid())
  name                   String
  rename                 String?
  notes                  String?
  type                   String
  selected               Boolean                 @default(true)
  unit                   String?
  tableId                String
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt
  table                  Table                   @relation(fields: [tableId], references: [id], onDelete: Cascade)
  targetRelationMappings RelationColumnMapping[] @relation("mapping_target")
  sourceRelationMappings RelationColumnMapping[] @relation("mapping_source")
  conditions             TableCondition[]
  augmentation           ColumnAugmentation?

  @@unique([tableId, name])
}

model ComputedColumn {
  id        String   @id @default(uuid())
  name      String
  type      String
  ast       String
  selected  Boolean  @default(true)
  unit      String?
  notes     String?
  tableId   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  table     Table    @relation(fields: [tableId], references: [id], onDelete: Cascade)

  @@unique([tableId, name])
}

model Relation {
  id             String                  @id @default(uuid())
  name           String
  isList         Boolean
  selected       Boolean                 @default(true)
  source         String                  @default("FK")
  status         String                  @default("VALID")
  errorTag       String?
  sourceTableId  String
  targetTableId  String
  createdAt      DateTime                @default(now())
  updatedAt      DateTime                @updatedAt
  targetTable    Table                   @relation("relation_target", fields: [targetTableId], references: [id], onDelete: Cascade)
  sourceTable    Table                   @relation("relation_source", fields: [sourceTableId], references: [id], onDelete: Cascade)
  columnMappings RelationColumnMapping[]

  @@unique([sourceTableId, name])
}

model RelationColumnMapping {
  id               String   @id @default(uuid())
  relationId       String
  sourceColumnId   String?
  targetColumnId   String?
  sourceColumnName String
  targetColumnName String
  position         Int
  targetColumn     Column?  @relation("mapping_target", fields: [targetColumnId], references: [id])
  sourceColumn     Column?  @relation("mapping_source", fields: [sourceColumnId], references: [id])
  relation         Relation @relation(fields: [relationId], references: [id], onDelete: Cascade)

  @@unique([relationId, position])
}

model ColumnAugmentation {
  id                String                           @id @default(uuid())
  kind              ColumnAugmentationKind
  selected          Boolean                          @default(true)
  columnId          String                           @unique
  tableId           String
  table             Table                            @relation(fields: [tableId], references: [id], onDelete: Cascade)
  column            Column                           @relation(fields: [columnId], references: [id], onDelete: Cascade)
  conversionConfig  ColumnAugmentationConversion?
  staticEnumConfig  ColumnAugmentationStaticEnum?
  dynamicEnumConfig ColumnAugmentationDynamicEnum?

  @@index([tableId])
}

model ColumnAugmentationConversion {
  id             String             @id @default(uuid())
  ast            String
  type           String?
  augmentationId String             @unique
  augmentation   ColumnAugmentation @relation(fields: [augmentationId], references: [id], onDelete: Cascade)
}

model ColumnAugmentationStaticEnum {
  id             String             @id @default(uuid())
  entries        String
  augmentationId String             @unique
  augmentation   ColumnAugmentation @relation(fields: [augmentationId], references: [id], onDelete: Cascade)
}

model ColumnAugmentationDynamicEnum {
  id             String             @id @default(uuid())
  augmentationId String             @unique
  augmentation   ColumnAugmentation @relation(fields: [augmentationId], references: [id], onDelete: Cascade)
}

model TableCondition {
  id                 String           @id @default(uuid())
  columnId           String
  tableId            String           @unique
  userContextFieldId String
  userContextField   UserContextField @relation(fields: [userContextFieldId], references: [id], onDelete: Cascade)
  table              Table            @relation(fields: [tableId], references: [id], onDelete: Cascade)
  column             Column           @relation(fields: [columnId], references: [id], onDelete: Cascade)
}

model UserContextField {
  id              String           @id @default(uuid())
  key             String           @unique
  type            String
  tableConditions TableCondition[]
  tableAccessPolicies TableAccessPolicy[]
}

model TableAccessPolicy {
  id                 String           @id @default(uuid())
  tableId            String           @unique
  userContextFieldId String
  userContextField   UserContextField @relation(fields: [userContextFieldId], references: [id], onDelete: Cascade)
  table              Table            @relation(fields: [tableId], references: [id], onDelete: Cascade)
}

model UserContextConfig {
  id     String            @id @default(uuid())
  status UserContextStatus @default(UNSET)
}

enum UserContextStatus {
  UNSET
  ENABLED
  DISABLED
}

enum ColumnAugmentationKind {
  CONVERSION
  STATIC_ENUM
  DYNAMIC_ENUM
}

model Conversation {
  id             String   @id
  userIdentifier String
  userContext    String?
  title          String?
  messages       String   @default("[]")
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([userIdentifier])
}

model checkpoints {
  thread_id            String
  checkpoint_ns        String  @default("")
  checkpoint_id        String
  parent_checkpoint_id String?
  type                 String?
  checkpoint           Bytes?
  metadata             Bytes?

  @@id([thread_id, checkpoint_ns, checkpoint_id])
}

model writes {
  thread_id     String
  checkpoint_ns String  @default("")
  checkpoint_id String
  task_id       String
  idx           Int
  channel       String
  type          String?
  value         Bytes?

  @@id([thread_id, checkpoint_ns, checkpoint_id, task_id, idx])
}
