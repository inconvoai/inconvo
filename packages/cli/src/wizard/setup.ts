import * as p from "@clack/prompts";
import * as fs from "fs/promises";
import * as path from "path";
import * as os from "os";
import { Kysely, PostgresDialect, MysqlDialect, MssqlDialect } from "kysely";
import { Pool } from "pg";
import { createPool as createMysqlPool } from "mysql2";

export type DatabaseDialect = "postgresql" | "mysql" | "mssql";

async function testDatabaseConnection(
  dialect: DatabaseDialect,
  connectionUrl: string
): Promise<void> {
  let db: Kysely<unknown>;

  if (dialect === "postgresql") {
    db = new Kysely({
      dialect: new PostgresDialect({
        pool: new Pool({ connectionString: connectionUrl }),
      }),
    });
  } else if (dialect === "mysql") {
    const mysqlPool = createMysqlPool({ uri: connectionUrl });
    db = new Kysely({
      dialect: new MysqlDialect({
        pool: mysqlPool as never,
      }),
    });
  } else if (dialect === "mssql") {
    const url = new URL(connectionUrl);
    const [username, password] =
      url.username && url.password
        ? [url.username, url.password]
        : url.pathname.slice(1).split(":");

    /* eslint-disable @typescript-eslint/no-require-imports */
    const tedious = require("tedious");
    const tarn = require("tarn");
    /* eslint-enable @typescript-eslint/no-require-imports */

    db = new Kysely({
      dialect: new MssqlDialect({
        tarn: {
          ...tarn,
          options: {
            min: 0,
            max: 1,
            acquireTimeoutMillis: 10000,
            createTimeoutMillis: 10000,
            destroyTimeoutMillis: 5000,
            idleTimeoutMillis: 10000,
          },
        },
        tedious: {
          ...tedious,
          connectionFactory: async () => {
            const connection = new tedious.Connection({
              server: url.hostname,
              authentication: {
                type: "default",
                options: {
                  userName: decodeURIComponent(username ?? ""),
                  password: decodeURIComponent(password ?? ""),
                },
              },
              options: {
                port: parseInt(url.port ?? "1433"),
                database:
                  url.pathname.split("/")[1] ??
                  url.searchParams.get("database") ??
                  "master",
                encrypt: url.searchParams.get("encrypt") === "true",
                trustServerCertificate:
                  url.searchParams.get("trustServerCertificate") !== "false",
                connectTimeout: 10000,
              },
            });
            return connection;
          },
        },
      }),
    });
  } else {
    const _exhaustiveCheck: never = dialect;
    throw new Error(`Unsupported dialect: ${String(_exhaustiveCheck)}`);
  }

  try {
    await db
      .selectFrom("information_schema.tables" as never)
      .limit(1)
      .execute();
  } finally {
    await db.destroy();
  }
}

interface SetupConfig {
  databaseDialect: DatabaseDialect;
  databaseUrl: string;
  databaseSchema?: string;
  openaiApiKey: string;
  useDemo: boolean;
}

async function writeEnvFile(
  config: SetupConfig,
  envPath: string
): Promise<void> {
  const localSecretKey = `local-dev-${crypto.randomUUID()}`;

  const lines: string[] = [
    "# Inconvo Dev Server Configuration",
    "# Generated by inconvo configure",
    "",
    "# Database Configuration",
    `DATABASE_DIALECT=${config.databaseDialect}`,
    `INCONVO_DATABASE_URL=${config.databaseUrl}`,
  ];

  if (config.databaseSchema) {
    lines.push(`INCONVO_DATABASE_SCHEMA=${config.databaseSchema}`);
  }

  lines.push(
    "",
    "# Connect Configuration (for local query execution)",
    `INCONVO_SECRET_KEY=${localSecretKey}`,
    "",
    "# LLM Configuration",
    `OPENAI_API_KEY=${config.openaiApiKey}`,
    "",
    "# Demo Mode",
    `USE_DEMO_DATABASE=${config.useDemo ? "true" : "false"}`,
    "",
    "# Telemetry (anonymous usage data to help improve Inconvo)",
    "# Run 'inconvo telemetry off' to disable",
    "DISABLE_TELEMETRY=false",
    ""
  );

  await fs.writeFile(envPath, lines.join("\n"));
}

export function getInconvoDir(): string {
  return path.join(os.homedir(), ".inconvo");
}

export function getEnvPath(): string {
  return path.join(getInconvoDir(), "config.env");
}

export async function envExists(): Promise<boolean> {
  try {
    await fs.access(getEnvPath());
    return true;
  } catch {
    return false;
  }
}

export async function ensureInconvoDir(): Promise<void> {
  const dir = getInconvoDir();
  await fs.mkdir(dir, { recursive: true });
}

export async function readEnvFile(): Promise<Record<string, string>> {
  const envPath = getEnvPath();
  try {
    const content = await fs.readFile(envPath, "utf-8");
    const env: Record<string, string> = {};
    for (const line of content.split("\n")) {
      const trimmed = line.trim();
      if (trimmed && !trimmed.startsWith("#")) {
        const [key, ...valueParts] = trimmed.split("=");
        if (key) {
          env[key] = valueParts.join("=");
        }
      }
    }
    return env;
  } catch {
    return {};
  }
}

export async function runSetupWizard(): Promise<boolean> {
  p.intro("Inconvo Configuration Setup");

  const envPath = getEnvPath();

  // Ensure ~/.inconvo directory exists
  await ensureInconvoDir();

  // Check if config already exists
  if (await envExists()) {
    const shouldOverwrite = await p.confirm({
      message: `Configuration already exists at ${envPath}. Do you want to overwrite it?`,
      initialValue: false,
    });

    if (p.isCancel(shouldOverwrite) || !shouldOverwrite) {
      p.cancel("Setup cancelled. Existing configuration preserved.");
      return false;
    }
  }

  // Database source selection
  const databaseSource = await p.select({
    message: "Choose your database:",
    options: [
      {
        value: "demo",
        label: "Demo database",
        hint: "PostgreSQL in Docker - great for trying out Inconvo",
      },
      {
        value: "own",
        label: "My own database",
        hint: "Connect to your existing database",
      },
    ],
  });

  if (p.isCancel(databaseSource)) {
    p.cancel("Setup cancelled.");
    return false;
  }

  const useDemo = databaseSource === "demo";
  let databaseDialect: DatabaseDialect;
  let databaseUrl: string;
  let databaseSchema: string | undefined;

  if (useDemo) {
    // Demo database configuration - uses Docker container
    databaseDialect = "postgresql";
    databaseUrl = "postgresql://inconvo:inconvo@demo-db:5432/demo";
    databaseSchema = "public";
    p.log.info("Demo database will be started in a Docker container.");
  } else {
    // User's own database
    const dialectChoice = await p.select({
      message: "Select your database type:",
      options: [
        { value: "postgresql", label: "PostgreSQL", hint: "recommended" },
        { value: "mysql", label: "MySQL" },
        { value: "mssql", label: "Microsoft SQL Server" },
      ],
    });

    if (p.isCancel(dialectChoice)) {
      p.cancel("Setup cancelled.");
      return false;
    }

    databaseDialect = dialectChoice as DatabaseDialect;

    // Connection string
    const placeholders: Record<DatabaseDialect, string> = {
      postgresql: "postgresql://user:password@localhost:5432/database",
      mysql: "mysql://user:password@localhost:3306/database",
      mssql: "mssql://user:password@localhost:1433/database",
    };

    const urlInput = await p.text({
      message: "Enter your database connection string:",
      placeholder: placeholders[databaseDialect],
      validate: (value) => {
        if (!value) return "Connection string is required";
        try {
          new URL(value);
          return undefined;
        } catch {
          return "Please enter a valid connection URL";
        }
      },
    });

    if (p.isCancel(urlInput)) {
      p.cancel("Setup cancelled.");
      return false;
    }

    databaseUrl = urlInput;

    // Database schema (optional)
    const schemaInput = await p.text({
      message: "Database schema (optional, press Enter to skip):",
      placeholder: databaseDialect === "postgresql" ? "public" : "",
    });

    if (p.isCancel(schemaInput)) {
      p.cancel("Setup cancelled.");
      return false;
    }

    databaseSchema = schemaInput || undefined;

    // Test database connection
    const spinner = p.spinner();
    spinner.start("Testing database connection...");

    try {
      await testDatabaseConnection(databaseDialect, databaseUrl);
      spinner.stop("Database connection successful!");
    } catch (error) {
      spinner.stop("Database connection failed");
      p.log.error(
        `Connection error: ${error instanceof Error ? error.message : String(error)}`
      );

      const retry = await p.confirm({
        message: "Would you like to enter a different connection string?",
        initialValue: true,
      });

      if (p.isCancel(retry) || !retry) {
        p.cancel("Setup cancelled.");
        return false;
      }

      return runSetupWizard();
    }
  }

  // OpenAI API key
  const openaiApiKey = await p.text({
    message: "Enter your OpenAI API key:",
    placeholder: "sk-...",
    validate: (value) => {
      if (!value) return "OpenAI API key is required";
      if (!value.startsWith("sk-")) return "Invalid OpenAI API key format";
      return undefined;
    },
  });

  if (p.isCancel(openaiApiKey)) {
    p.cancel("Setup cancelled.");
    return false;
  }

  // Write configuration
  const saveSpinner = p.spinner();
  saveSpinner.start("Saving configuration...");

  try {
    await writeEnvFile(
      {
        databaseDialect,
        databaseUrl,
        databaseSchema,
        openaiApiKey,
        useDemo,
      },
      envPath
    );
    saveSpinner.stop(`Configuration saved to ${envPath}`);
  } catch (error) {
    saveSpinner.stop("Failed to save configuration");
    p.log.error(
      `Error: ${error instanceof Error ? error.message : String(error)}`
    );
    return false;
  }

  p.outro("Setup complete! Run `inconvo dev` to start the dev server.");

  return true;
}
