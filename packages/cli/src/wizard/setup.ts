import * as p from "@clack/prompts";
import * as fs from "fs/promises";
import * as path from "path";
import * as os from "os";
import { Kysely, PostgresDialect, MysqlDialect, MssqlDialect } from "kysely";
import { Pool } from "pg";
import { createPool as createMysqlPool } from "mysql2";

export type DatabaseDialect = "postgresql" | "mysql" | "mssql";

async function testDatabaseConnection(
  dialect: DatabaseDialect,
  connectionUrl: string
): Promise<void> {
  let db: Kysely<unknown>;

  if (dialect === "postgresql") {
    db = new Kysely({
      dialect: new PostgresDialect({
        pool: new Pool({ connectionString: connectionUrl }),
      }),
    });
  } else if (dialect === "mysql") {
    const mysqlPool = createMysqlPool({ uri: connectionUrl });
    db = new Kysely({
      dialect: new MysqlDialect({
        pool: mysqlPool as never,
      }),
    });
  } else if (dialect === "mssql") {
    const url = new URL(connectionUrl);
    const [username, password] =
      url.username && url.password
        ? [url.username, url.password]
        : url.pathname.slice(1).split(":");

    /* eslint-disable @typescript-eslint/no-require-imports */
    const tedious = require("tedious");
    const tarn = require("tarn");
    /* eslint-enable @typescript-eslint/no-require-imports */

    db = new Kysely({
      dialect: new MssqlDialect({
        tarn: {
          ...tarn,
          options: {
            min: 0,
            max: 1,
            acquireTimeoutMillis: 10000,
            createTimeoutMillis: 10000,
            destroyTimeoutMillis: 5000,
            idleTimeoutMillis: 10000,
          },
        },
        tedious: {
          ...tedious,
          connectionFactory: async () => {
            const connection = new tedious.Connection({
              server: url.hostname,
              authentication: {
                type: "default",
                options: {
                  userName: decodeURIComponent(username ?? ""),
                  password: decodeURIComponent(password ?? ""),
                },
              },
              options: {
                port: parseInt(url.port ?? "1433"),
                database:
                  url.pathname.split("/")[1] ??
                  url.searchParams.get("database") ??
                  "master",
                encrypt: url.searchParams.get("encrypt") === "true",
                trustServerCertificate:
                  url.searchParams.get("trustServerCertificate") !== "false",
                connectTimeout: 10000,
              },
            });
            return connection;
          },
        },
      }),
    });
  } else {
    const _exhaustiveCheck: never = dialect;
    throw new Error(`Unsupported dialect: ${String(_exhaustiveCheck)}`);
  }

  try {
    await db
      .selectFrom("information_schema.tables" as never)
      .limit(1)
      .execute();
  } finally {
    await db.destroy();
  }
}

interface SetupConfig {
  databaseDialect: DatabaseDialect;
  databaseUrl: string;
  databaseSchema?: string;
  openaiApiKey: string;
  langchainApiKey: string;
}

async function writeEnvFile(
  config: SetupConfig,
  envPath: string
): Promise<void> {
  const localSecretKey = `local-dev-${crypto.randomUUID()}`;

  const lines: string[] = [
    "# Inconvo Dev Server Configuration",
    "# Generated by inconvo configure",
    "",
    "# Database Configuration",
    `DATABASE_DIALECT=${config.databaseDialect}`,
    `INCONVO_DATABASE_URL=${config.databaseUrl}`,
  ];

  if (config.databaseSchema) {
    lines.push(`INCONVO_DATABASE_SCHEMA=${config.databaseSchema}`);
  }

  lines.push(
    "",
    "# Connect Configuration (for local query execution)",
    `INCONVO_SECRET_KEY=${localSecretKey}`,
    "",
    "# LLM Configuration",
    `OPENAI_API_KEY=${config.openaiApiKey}`,
    "",
    "# LangChain Configuration",
    `LANGCHAIN_API_KEY=${config.langchainApiKey}`,
    ""
  );

  await fs.writeFile(envPath, lines.join("\n"));
}

export function getInconvoDir(): string {
  return path.join(os.homedir(), ".inconvo");
}

export function getEnvPath(): string {
  return path.join(getInconvoDir(), "config.env");
}

export async function envExists(): Promise<boolean> {
  try {
    await fs.access(getEnvPath());
    return true;
  } catch {
    return false;
  }
}

export async function ensureInconvoDir(): Promise<void> {
  const dir = getInconvoDir();
  await fs.mkdir(dir, { recursive: true });
}

export async function readEnvFile(): Promise<Record<string, string>> {
  const envPath = getEnvPath();
  try {
    const content = await fs.readFile(envPath, "utf-8");
    const env: Record<string, string> = {};
    for (const line of content.split("\n")) {
      const trimmed = line.trim();
      if (trimmed && !trimmed.startsWith("#")) {
        const [key, ...valueParts] = trimmed.split("=");
        if (key) {
          env[key] = valueParts.join("=");
        }
      }
    }
    return env;
  } catch {
    return {};
  }
}

export async function runSetupWizard(): Promise<boolean> {
  p.intro("Inconvo Configuration Setup");

  const envPath = getEnvPath();

  // Ensure ~/.inconvo directory exists
  await ensureInconvoDir();

  // Check if config already exists
  if (await envExists()) {
    const shouldOverwrite = await p.confirm({
      message: `Configuration already exists at ${envPath}. Do you want to overwrite it?`,
      initialValue: false,
    });

    if (p.isCancel(shouldOverwrite) || !shouldOverwrite) {
      p.cancel("Setup cancelled. Existing configuration preserved.");
      return false;
    }
  }

  // Database type selection
  const databaseDialect = await p.select({
    message: "Select your database type:",
    options: [
      { value: "postgresql", label: "PostgreSQL", hint: "recommended" },
      { value: "mysql", label: "MySQL" },
      { value: "mssql", label: "Microsoft SQL Server" },
    ],
  });

  if (p.isCancel(databaseDialect)) {
    p.cancel("Setup cancelled.");
    return false;
  }

  // Connection string
  const placeholders: Record<DatabaseDialect, string> = {
    postgresql: "postgresql://user:password@localhost:5432/database",
    mysql: "mysql://user:password@localhost:3306/database",
    mssql: "mssql://user:password@localhost:1433/database",
  };

  const databaseUrl = await p.text({
    message: "Enter your database connection string:",
    placeholder: placeholders[databaseDialect as DatabaseDialect],
    validate: (value) => {
      if (!value) return "Connection string is required";
      try {
        new URL(value);
        return undefined;
      } catch {
        return "Please enter a valid connection URL";
      }
    },
  });

  if (p.isCancel(databaseUrl)) {
    p.cancel("Setup cancelled.");
    return false;
  }

  // Database schema (optional)
  const databaseSchema = await p.text({
    message: "Database schema (optional, press Enter to skip):",
    placeholder: databaseDialect === "postgresql" ? "public" : "",
  });

  if (p.isCancel(databaseSchema)) {
    p.cancel("Setup cancelled.");
    return false;
  }

  // Test database connection
  const spinner = p.spinner();
  spinner.start("Testing database connection...");

  try {
    await testDatabaseConnection(
      databaseDialect as DatabaseDialect,
      databaseUrl
    );
    spinner.stop("Database connection successful!");
  } catch (error) {
    spinner.stop("Database connection failed");
    p.log.error(
      `Connection error: ${error instanceof Error ? error.message : String(error)}`
    );

    const retry = await p.confirm({
      message: "Would you like to enter a different connection string?",
      initialValue: true,
    });

    if (p.isCancel(retry) || !retry) {
      p.cancel("Setup cancelled.");
      return false;
    }

    return runSetupWizard();
  }

  // OpenAI API key
  const openaiApiKey = await p.text({
    message: "Enter your OpenAI API key:",
    placeholder: "sk-...",
    validate: (value) => {
      if (!value) return "OpenAI API key is required";
      if (!value.startsWith("sk-")) return "Invalid OpenAI API key format";
      return undefined;
    },
  });

  if (p.isCancel(openaiApiKey)) {
    p.cancel("Setup cancelled.");
    return false;
  }

  // LangChain API key
  const langchainApiKey = await p.text({
    message: "Enter your LangChain API key (for prompts):",
    placeholder: "lsv2_pt_...",
    validate: (value) => {
      if (!value) return "LangChain API key is required";
      return undefined;
    },
  });

  if (p.isCancel(langchainApiKey)) {
    p.cancel("Setup cancelled.");
    return false;
  }

  // Write configuration
  spinner.start("Saving configuration...");

  try {
    await writeEnvFile(
      {
        databaseDialect: databaseDialect as DatabaseDialect,
        databaseUrl,
        databaseSchema: databaseSchema || undefined,
        openaiApiKey,
        langchainApiKey,
      },
      envPath
    );
    spinner.stop(`Configuration saved to ${envPath}`);
  } catch (error) {
    spinner.stop("Failed to save configuration");
    p.log.error(
      `Error: ${error instanceof Error ? error.message : String(error)}`
    );
    return false;
  }

  p.outro("Setup complete! Run `inconvo dev` to start the dev server.");

  return true;
}
